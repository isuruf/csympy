#include <symengine/symengine_config.h>

#ifdef HAVE_STRTOD_L
#if defined(__GNUC__) && !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif
#include <stdlib.h>
#ifdef __APPLE__
#include <xlocale.h>
#else
#include <locale.h>
#endif
#endif

#include "parserbase.h"
#include "scanner.h"
#include <fstream>
#include "parser.h"

namespace SymEngine
{
// $insert lex
inline int Parser::lex()
{
    return d_scanner.lex();
}

inline void Parser::print()
{
    print__(); // displays tokens if --print was specified
}

RCP<const Basic> parse(const std::string &s, bool convert_xor)
{
    Parser p(s, convert_xor);

    if (p.parse() == 0)
        return p.res;

    throw ParseError("Parsing Unsuccessful");
}

RCP<const Basic> Parser::functionify(const std::string &name, vec_basic &params)
{
    if (params.size() == 1) {
        if (single_arg_functions.find(name) != single_arg_functions.end()) {
            return single_arg_functions[name](params[0]);
        }
        if (single_arg_boolean_functions.find(name)
            != single_arg_boolean_functions.end()) {
            return single_arg_boolean_functions[name](params[0]);
        }
        if (single_arg_boolean_boolean_functions.find(name)
            != single_arg_boolean_boolean_functions.end()) {
            return single_arg_boolean_boolean_functions[name](
                rcp_static_cast<const Boolean>(params[0]));
        }
    }

    if (params.size() == 2) {
        if (double_arg_functions.find(name) != double_arg_functions.end()) {
            return double_arg_functions[name](params[0], params[1]);
        }
        if (double_arg_boolean_functions.find(name)
            != double_arg_boolean_functions.end()) {
            return double_arg_boolean_functions[name](params[0], params[1]);
        }
    }

    if (multi_arg_functions.find(name) != multi_arg_functions.end()) {
        return multi_arg_functions[name](params);
    }

    if (multi_arg_vec_boolean_functions.find(name)
        != multi_arg_vec_boolean_functions.end()) {
        vec_boolean p;
        for (auto &v : params) {
            p.push_back(rcp_static_cast<const Boolean>(v));
        }
        return multi_arg_vec_boolean_functions[name](p);
    }

    if (multi_arg_set_boolean_functions.find(name)
        != multi_arg_set_boolean_functions.end()) {
        set_boolean s;
        for (auto &v : params) {
            s.insert(rcp_static_cast<const Boolean>(v));
        }
        return multi_arg_set_boolean_functions[name](s);
    }

    return function_symbol(name, params);
}

RCP<const Basic> Parser::parse_identifier(const std::string &expr)
{
    auto c = constants.find(expr);
    if (c != constants.end()) {
        return c->second;
    } else {
        return symbol(expr);
    }
}

#ifdef HAVE_STRTOD_L
static int strtod_locale_initialized = 0;
#ifdef _WIN32
static _locale_t strtod_locale;
#else
static locale_t strtod_locale;
#endif
#endif

inline double symengine_strtod(const char *startptr, char** endptr) {
#ifdef HAVE_STRTOD_L
    if(!strtod_locale_initialized)
    {
        strtod_locale_initialized = 1;
        strtod_locale = newlocale(LC_ALL_MASK, "C", NULL);
    }
#ifdef _WIN32
    return _strtod_l(startptr, endptr, strtod_locale);
#else
    return strtod_l(startptr, endptr, strtod_locale);
#endif
#else
    return strtod(startptr, endptr);
#endif
}

RCP<const Basic> Parser::parse_numeric(const std::string &expr)
{
    const char *startptr = expr.c_str();
    char *lendptr;
    // if the expr is numeric, it's either a float or an integer
    errno = 0;
    long l = std::strtol(startptr, &lendptr, 0);

    // Number is a long;
    if (expr.find_first_of('.') == std::string::npos && lendptr == startptr+expr.length()) {
        if (errno != ERANGE) {
            // No overflow in l
            return integer(l);
        } else {
            return integer(integer_class(expr));
        }
    } else {
#ifdef HAVE_SYMENGINE_MPFR
        unsigned digits = 0;
        for (size_t i = 0; i < expr.length(); ++i) {
            if (expr[i] == '.' or expr[i] == '-')
                continue;
            if (expr[i] == 'E' or expr[i] == 'e')
                break;
            if (digits != 0 or expr[i] != '0') {
                ++digits;
            }
        }
        if (digits <= 15) {
            char *endptr = 0;
            double d = symengine_strtod(startptr, &endptr);
            return real_double(d);
        } else {
            // mpmath.libmp.libmpf.dps_to_prec
            long prec
                = std::max(long(1), std::lround((digits + 1)
                                                * 3.3219280948873626));
            return real_mpfr(mpfr_class(expr, prec));
        }
#else
        char *endptr = 0;
        double d = symengine_strtod(startptr, &endptr);
        return real_double(d);
#endif
    }
}

std::tuple<RCP<const Basic>, RCP<const Basic>> Parser::parse_implicit_mul(const std::string &expr)
{
    const char *startptr = expr.c_str();
    char *endptr = 0;
    symengine_strtod(startptr, &endptr);

    RCP<const Basic> num = one, sym;

    // Numerical part of the result of e.g. "100x";
    size_t length = endptr - startptr;
    std::string lexpr = std::string(startptr, length);
    num = parse_numeric(lexpr);

    // get the rest of the string
    lexpr = std::string(startptr + length, expr.length() - length);
    if (lexpr.length() == 0) {
        sym = one;
    } else {
        sym = parse_identifier(lexpr);
    }
    return std::make_tuple(num, sym);
}

}
